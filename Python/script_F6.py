#!/usr/bin/env python3# -*- coding: utf-8 -*-"""Created on Tue Jul 23 13:09:22 2025Script that plots Oracle's estimates of the inter-event time distribution and conditional intensity function, for all events in a test case.Used to make Figures 6 & S22."""# Import relevant libraries.import torchimport numpy as npimport matplotlib.pyplot as pltfrom torch.distributions import Categoricalimport eqfrom eq.catalogs import IScasesimport eq.distributions as dist# Pick the case for plotting.partition_list = ['Basel','SSFS','CB','St1','FORGE','PNR1','PNR2']test_case = 'Basel'test_partition = 'Basel'val_partition = 'FORGE'Tmean = 100f = 0.2# Get the save path for models.oracle_model_savepath = 'models/Vanilla/Model_' + test_partition + '_' + val_partition + '.pt'etas_model_savepath = 'models/ETAS/Model_' + test_case + '_etas.pt'# Get the corresponding Oracle model.model_O = eq.models.Oracle()model_O.load_state_dict(torch.load(oracle_model_savepath))model_O.eval()# Get some data for plotting.d = next(iter(IScases(test_case).dataset.get_dataloaderIS()))seq =  d.get_sequence(0)m = model_O.get_marks(d)p = model_O.get_pre_params(m)dT = model_O.get_dT_dist(p)dTmean = dT.mean[0]# Construct the adjusted distribution.component_dist = dist.Weibull(log_mean=(dT.component_distribution.mean*Tmean/dT.mean.unsqueeze(-1)).log(), shape=dT.component_distribution.shape) # (B, L, Ct)mixture_dist = Categorical(logits=dT.mixture_distribution.logits)dT2 = dist.MixtureSameFamily(mixture_distribution=mixture_dist,component_distribution=component_dist)# Test loss.print('Test loss')print(model_O.loss(d))# Get the mean rates from fitting.Rm = dT2.mean.squeeze(0).detach().numpy()Rm = -np.log10((Rm[0:-1]))# Get the fitted conditional intensity function values (i.e., the hazard function).th,Rh = model_O.evaluate_intensity(sequence=seq,num_grid_points=0)th = th.numpy()Rh = Rh.log10().detach().numpy()# Get some compensator values from fitting.tc,Cf = model_O.evaluate_compensator(sequence=seq,num_grid_points=0)tc = tc.numpy()Cf = Cf.detach().numpy()# Prep the input data for plotting.te = seq.arrival_times.numpy()Re = -np.log10(seq.inter_times.numpy()[0:-1])ti = seq.inj_time.numpy()Vi = seq.inj_rate.numpy()# Get the relevant distributions.T=torch.pow(10,torch.arange(start=-10,end=+10,step=0.01)).unsqueeze(1)PDF = dT2.log_prob(T)HAZ = dT2.log_hazard(T)# Make into numpy arrays.T = T.detach().numpy()dTmean = dTmean.detach().numpy()PDF = PDF.detach().numpy()HAZ = HAZ.detach().numpy()# Sample points to show.#n=5#i_range=np.arange(round(c.shape[1]/n/2),c.shape[1],round(c.shape[1]/n))i_range = np.arange(0,round(len(te)*f))f_mean = np.zeros_like(T)h_mean = np.zeros_like(T)# An Omori decay fxn.a = torch.load(etas_model_savepath)p = a['log_pt'].exp().detach().numpy()c = a['log_ct'].exp().detach().numpy()K = 10Oh = np.log( ((p-1)*(T+c)**(-p))/(c**(1-p)) ) + np.log(K)Oh = np.log(p-1) - p*np.log(T+c) - (1-p)*np.log(c) + np.log(K)Of = Oh - K*(c**(1-p)-(T+c)**(1-p))/(c**(1-p))# Add exponential decay.tau = TmeanEf = -T/tau - np.log(tau)Eh = -np.log(tau) * np.ones_like(T)## Plotting.# Plot the inter-event time PDF and hazard function.fig = plt.figure()fig.set_size_inches(9.5, 4.5)gs = fig.add_gridspec(2, hspace=0)axs = gs.subplots(sharex=True, sharey=False)for j, i in enumerate(i_range):    axs[0].plot(np.log10(T), PDF[:,[i]], color='gray' )    #axs[0].plot(np.log10(dTmean[i]), np.interp(dTmean[i],T.flatten(),PDF[:,i]), color=colors[j], marker='o')    f_mean += PDF[:,[i]]/len(i_range)        axs[1].plot(np.log10(T), HAZ[:,[i]], color='gray')    #axs[1].plot(np.log10(dTmean[i]), np.interp(dTmean[i],T.flatten(),HAZ[:,i]), color=colors[j], marker='o')    h_mean += HAZ[:,[i]]/len(i_range)axs[0].plot(np.log10(T), f_mean, color='black' )axs[0].plot(np.log10(T), Ef, color='red' )axs[0].plot(np.log10(T), Of, color='blue' )axs[1].plot(np.log10(T), h_mean, color='black' )axs[1].plot(np.log10(T), Eh, color='red' )axs[1].plot(np.log10(T), Oh, color='blue' )axs[0].set_ylabel(r'$ln$ $f(\tau)$')axs[1].set_ylabel(r'$ln$ $\lambda(\tau)$')axs[1].set_xlabel('Inter-event Time (log$_{10}$[min])')axs[0].set_ylim(-40,+1)axs[1].set_ylim(-20,+0)axs[0].set_xlim(0,+10)plt.savefig('F6.eps', format='eps')plt.show()